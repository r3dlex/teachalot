#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass abntex2
\begin_preamble
% ---
% Pacotes fundamentais
% ---
\usepackage{cmap}                               % Mapear caracteres especiais no PDF
\usepackage{lmodern}                    % Usa a fonte Latin Modern
\usepackage{makeidx}            % Cria o indice
\usepackage{hyperref}                   % Controla a formação do índice
\usepackage{lastpage}                   % Usado pela Ficha catalográfica
\usepackage{indentfirst}                % Indenta o primeiro parágrafo de cada seção.
\usepackage{color}                              % Controle das cores
\usepackage{graphicx}                   % Inclusão de gráficos
\usepackage{xcolor}
\usepackage{minted}               		
% ---

% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}                             % para geração de dummy text
% ---

% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}     % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}   % Citações padrão ABNT

% ---
% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
        \ifcase #1 %
                Nenhuma citação no texto.%
        \or
                Citado na página #2.%
        \else
                Citado #1 vezes nas páginas #2.%
        \fi}%
% ---

% ---
% Minted - Source code
% ---
\newminted{java}{
  fontsize=\footnotesize, 
  linenos,
  frame=lines,
  bgcolor=bg,
  baselinestretch=1,
  tabsize=2
} 
% ---

\newminted{javasnip}{
  fontsize=\footnotesize, 
  frame=lines,
  bgcolor=bg,
  baselinestretch=1,
  tabsize=2
} 

\definecolor{bg}{rgb}{1.0,1.0,1.0}


% ---
% Espaçamentos entre linhas e parágrafos
% ---

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip
% ---

% Variáveis relacionadas a Apostila
\titulo{LINGUAGEM DE PROGRAMAÇÃO C}
\autor{André Ferreira Bem Silva}
\instituicao{CESUSC}
\tipotrabalho{Apostila}
\data{2015}
% ---

% ---
% compila o indice
% ---
\makeindex
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language brazilian
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% informações do PDF
\end_layout

\begin_layout Plain Layout


\backslash
hypersetup{
\end_layout

\begin_layout Plain Layout

        %pagebackref=true,
\end_layout

\begin_layout Plain Layout

                pdftitle={
\backslash
imprimirtitulo},
\end_layout

\begin_layout Plain Layout

                pdfauthor={
\backslash
imprimirautor},
\end_layout

\begin_layout Plain Layout

        pdfsubject={
\backslash
imprimirpreambulo},
\end_layout

\begin_layout Plain Layout

                pdfkeywords={PALAVRAS}{CHAVES}{abnt}{abntex}{abntex2},
\end_layout

\begin_layout Plain Layout

            pdfproducer={LaTeX with abnTeX2},   % producer of the document
\end_layout

\begin_layout Plain Layout

            pdfcreator={
\backslash
imprimirautor},
\end_layout

\begin_layout Plain Layout

        colorlinks=true,                % false: boxed links; true: colored
 links
\end_layout

\begin_layout Plain Layout

        linkcolor=blue,                 % color of internal links
\end_layout

\begin_layout Plain Layout

        citecolor=blue,                 % color of links to bibliography
\end_layout

\begin_layout Plain Layout

        filecolor=magenta,                      % color of file links
\end_layout

\begin_layout Plain Layout

                urlcolor=blue,
\end_layout

\begin_layout Plain Layout

                bookmarksdepth=4
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout

% Capa
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout


\backslash
imprimircapa
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout

% Folha de rosto
\end_layout

\begin_layout Plain Layout

% (o * indica que haverá a ficha bibliográfica)
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout


\backslash
imprimirfolhaderosto*
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout

% inserir o sumario
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\begin_layout Plain Layout


\backslash
pdfbookmark[0]{
\backslash
contentsname}{toc}
\end_layout

\begin_layout Plain Layout


\backslash
tableofcontents*
\end_layout

\begin_layout Plain Layout


\backslash
cleardoublepage
\end_layout

\begin_layout Plain Layout

% ---
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%%Hides syntax errors on Minted lexer
\end_layout

\begin_layout Plain Layout


\backslash
expandafter
\backslash
def
\backslash
csname PY@tok@err
\backslash
endcsname{}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introdução a C
\end_layout

\begin_layout Standard
Denis Ritchie define, em 1970, uma linguagem a partir do BCPL nos laboratórios
 da Bell Telephones Inc.
 Esta linguagem foi chamada de B.
 Já em 1978, Brian Kerningham em conjunto com Ritchie aprimorou a linguagem.
 A nova versão passou a chama-se de C.
 Pelas suas características de portabilidade e estruturação já se tornou
 popular entre os programadores.
 Em 1980, a linguagem é padronizada pelo American National Standard Institute.
 Surge a linguagem ANSI C.
 Mais recentemente:
\end_layout

\begin_layout Itemize
1990: A Borland International Co.
 fabricante de compiladores profissionais escolhe o C e o Pascal como linguagens
 de trabalho para o seu Integrated Development Enviroment (Ambiente Integrado
 de Desenvolvimento).
 Surge a linguagem Turbo C.
 
\end_layout

\begin_layout Itemize
1992: O C se torna ponto de concordância entre teóricos do desenvolvimento
 da teoria de Object - Oriented Programming (programação orientada a objetos).
 Surge a linguagem C++.
\end_layout

\begin_layout Section
Caraterísticas
\end_layout

\begin_layout Standard
\align left
Linguagem de Nível Médio (combina recursos do Alto e Baixo Nível):
\end_layout

\begin_layout Itemize
Bastante Portátil
\end_layout

\begin_layout Itemize
Não é fortemente tipada;
\end_layout

\begin_layout Itemize
Permite a manipulação de bits, byte e endereços;
\end_layout

\begin_layout Itemize
Estruturada.
\end_layout

\begin_layout Section
Estrutura de um Programa
\end_layout

\begin_layout Standard
Todo programa C segue uma estrutura bem definida de símbolos léxicos, sintáticos
 e semânticos.
 Sendo assim, o estudo desses símbolos é de interesse para a compreensão
 da linguagem.
 Como foi desenvolvida como uma linguagem para programação de sistemas (
\emph on
Unix
\emph default
), o C é uma linguagem que possui diretivas simples para acesso a entrada
 e saída o que fica evidente nas poucas linhas do 
\emph on
hello world 
\emph default
escrito usando as funções da linguagem, no algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:HelloWorld"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/ola_mundo.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:HelloWorld"

\end_inset

O "Olá, Mundo!" (
\emph on
Hello World
\emph default
) em C.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Identificadores
\end_layout

\begin_layout Standard
São nomes usados para se fazer referencia a variáveis, funções, rótulos
 e vários outros objetos definidos pelo usuário.
 Regras:
\end_layout

\begin_layout Itemize
O primeiro caracter deve ser letra ou sublinha( _ ).
 
\end_layout

\begin_layout Itemize
Os caracteres seguintes devem ser letras, números ou sublinha.
 
\end_layout

\begin_layout Itemize
Os primeiros 32 (default) caracteres são significativos.
\end_layout

\begin_layout Subsection
Comentários
\end_layout

\begin_layout Standard
Os comentários do programador são feito da seguinte maneira:
\end_layout

\begin_layout Standard
/* Isto é um comentário */
\end_layout

\begin_layout Standard
// ou Isto
\end_layout

\begin_layout Subsection
Regras Gerais 
\end_layout

\begin_layout Standard
Um programa em "C" é constituído de uma ou mais funções delimitadas por
 chaves, onde uma é obrigatoriamente chamada main().
 
\end_layout

\begin_layout Itemize
Letras maiúsculas e minúsculas são tratadas como caracteres diferentes.
\end_layout

\begin_layout Itemize
O formato do texto é livre.
 
\end_layout

\begin_layout Itemize

\emph on
main() 
\emph default
especifica a função por onde o programa começar a ser executado.
 
\end_layout

\begin_layout Itemize
Todos os comandos são terminados por ponto e vírgula.
 
\end_layout

\begin_layout Itemize
Todas as variáveis devem ser declaradas.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/dia_mes_ano.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Programa que faz a impressão de dia, mês e ano no console
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Palavras reservadas
\end_layout

\begin_layout Standard
Estas palavras não podem ser utilizadas como nome de variáveis: 
\end_layout

\begin_layout Standard
\align center

\series bold
auto double if static const asm pascal break else int struct enum _ss _es
 case entry long switch signed interrupt huge chiar externa registre typedef
 void _cs continue float return union volatile cdecl default for sizeof
 unsigned near do goto short while _ds 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/declarando_var.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cálculo de potência 
\begin_inset Formula $x^{y}$
\end_inset

 em C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Declaração de variáveis
\end_layout

\begin_layout Standard
\align left
Sintaxe: TIPO lista_variáveis, onde:
\end_layout

\begin_layout Itemize
TIPO: deve ser um tipo de dado válido.
\end_layout

\begin_layout Itemize
lista_variáveis: um ou mais identificadores separados por vírgula.
\end_layout

\begin_layout Standard
\align left
Onde as variáveis são declaradas:
\end_layout

\begin_layout Itemize
Definidas fora de todas as funções, incluindo a função 
\emph on
main()
\emph default
 são chamadas de Variáveis Globais e podem ser usadas em qualquer parte
 do programa.
\end_layout

\begin_layout Itemize
Definidas dentro de uma função são chamadas de Variáveis Locais e só podem
 ser usadas dentro desta função.
\end_layout

\begin_layout Itemize
Na declaração de parâmetros formais de uma função.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/potencia.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Declarações de tipos inteiros
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Inicialização de variáveis
\end_layout

\begin_layout Standard
Em C é possível fornecermos valores para as variáveis ao mesmo tempo que
 as declaramos, colocando um sinal de igual e uma constante após o nome
 da variável:
\end_layout

\begin_layout Standard
\align center
TIPO nome_variável = constante; 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/var_init.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Declarações de tipos inteiros
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Constantes
\end_layout

\begin_layout Standard
Valores fixos que o programa não pode alterar.
 As constantes podem ser de qualquer tipo básico e podem aparecer em expressões
 diversas.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exemplos de constantes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'a' 'n' '9' 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1, 123, 2100 -234
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
123.23, 4.34e-3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
"C99", "Ola Mundo"
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Exemplos de constantes de cada tipo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Constantes hexadecimais e octais
\end_layout

\begin_layout Standard
C permite especificar constantes inteiras em hexadecimal ou octal.
 Uma constante octal (base 8) começa com um zero e uma Hexadecimal (base
 16) por 0x.
 Ex:
\end_layout

\begin_layout Standard
int hex = 0xFF; /* 255 em decimal */ 
\end_layout

\begin_layout Standard
int oct = 011; /* 9 em decimal */
\end_layout

\begin_layout Subsubsection
Constantes strings 
\end_layout

\begin_layout Standard
Uma string é um conjunto de caracteres que aparecem dentro de aspas duplas.
 
\end_layout

\begin_layout Standard
Exemplo: string = "C11" 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Assim, a memória total ocupada por "C11" é 4 bytes, e não 3 bytes como parece
 num primeiro instante.
 Outras observações: 
\end_layout

\begin_layout Itemize
'a' diferente de "a", uma vez que é "a" é 
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
Assim, "a" ocupa 2 bytes na memória
\end_layout

\begin_layout Itemize
Toda "string" é terminada por "
\backslash
0"
\end_layout

\begin_layout Subsubsection
Constantes especiais
\end_layout

\begin_layout Standard
Algumas constantes que são impossíveis de inserir pelo teclado e que possuem
 efeito especial ou significado especial.
 A lista:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constante
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Significado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
b
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retrocesso (
\emph on
backspace
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
f 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alimentação de formulário
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
n 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nova linha
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
r 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Retorno de Carro 
\emph on
<CR> 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
t 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tabulação horizontal (
\emph on
tab
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
"
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Aspas duplas
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Aspas simples
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Barra invertida
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
v
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tabulação vertical (
\emph on
tab
\emph default
)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Alerta
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
o
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constante octal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Constante hexadecimal
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Tipos de dados
\end_layout

\begin_layout Standard
Existem alguns tipos básicos de dados, os quais definem as variáveis 
\emph on
nativas
\emph default
.
 Esses tipos são inteiros, pontos flutuantes, caracteres ou sem tipo (
\emph on
void
\emph default
).
 Estão enumerados, assim como seus valores admitos, na tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:TiposDeDados"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tipo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Faixa de valor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[-128,127]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short (int)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[-32768,32767]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[\text{–}2.147.483.648,2.147.483.647]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long (int)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[\text{–}2.147.483.648,2.147.483.647]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long long (int)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[\text{–}9.223.372.036.854.775.808,9.223.372.036.854.775.807$
\end_inset

]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[-3.4E-38,3.4E+38]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[1.7E-308,1.7E+308]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
void
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sem valor
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:TiposDeDados"

\end_inset

Tipos básicos e seus respectivos tamanhos.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Modificadores de tipo
\end_layout

\begin_layout Standard
Um modificador é uma palavra-chave que pode ser usada para alterar o significado
 do tipo base para que ele se adapte conforme algumas necessidades específicas.
 Na tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:ModificadoresDeTipo"

\end_inset

, demonstram-se os modificadores de tipos, aplicáveis aqueles da tabela
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:TiposDeDados"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modificador
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Significado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
signed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
com sinal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sem sinal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
valor longo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
valor curto
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:ModificadoresDeTipo"

\end_inset

Modificadores de tipo aplicáveis aos tipos básicos, da tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:TiposDeDados"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Operadores
\end_layout

\begin_layout Standard
Os operadores são parte inerente das expressões e podem ser lógicos, relacionais
 ou aritméticos.
\end_layout

\begin_layout Subsection
Operadores Lógicos
\end_layout

\begin_layout Standard
As operações lógicas no C, são aquelas referentes a lógica clássica ou a
 lógica booleana.
 Apresenta operadores como o E, OU e a NEGAÇÃO.
 Sendo assim, são:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="45text%">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operador
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Função
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exemplo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&&
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se ambos os operandos são verdade, retorna 1, senão 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a && b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
||
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se um dos operandos é verdade, retorna 1, senão 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a || b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nega o valor atual, se for diferente de 0, retorna 1, senão 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!a
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Operadores Relacionais
\end_layout

\begin_layout Standard
Os operadores relacionais tem como resultado valores booleanos, portanto
 0 ou 1.
 Eles dependem de quais valores estão sendo comparados ou relacionados.
 As operações menor que, igual a, diferente de e maior possuem as seguintes
 sintaxes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operador
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ação
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
> 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maior que
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
maior ou igual a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
menor que
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
menor ou igua
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
==
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
igual a
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
diferente de
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Operadores Binários
\end_layout

\begin_layout Standard
Os operadores binários tem operação sobre bits, e sendo assim estão associados
 aos tamanhos das representações em questão.
 Levando em consideração, as variáveis p e q, ambas de 1 bit somente o resultado
 para um operador binário para os possíveis operadores para essas variáveis
 seria:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p & q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p | q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
p ˆ q
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operador
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ação
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exemplos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resultado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
subtração
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 - 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
adição
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2 + 7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
multiplicação
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2 * -3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
divisão
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 / 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
módulo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 % 3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
decremento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
incremento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
++3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4*
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\size footnotesize
*Quando pós-fixado, isto é, após o número ou símbolo, o operador retorna
 o valor atual, senão retorna já alterado.
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:OperadoresAritmeticos"

\end_inset

Tabela de operadores na linguagem C.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operadores Aritméticos
\end_layout

\begin_layout Standard
Os operadores aritméticos atuam sobre tipos inteiros e de ponto flutuante.
 Os operadores básicos de multiplicação, divisão, subtração, adição, módulo,
 incremento e decremento podem ser vistos na tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:OperadoresAritmeticos"

\end_inset

.
\end_layout

\begin_layout Standard
Os operadores são executados de acordo com as regras disponíveis na linguagem.
 A ordem que acontecem define a chamada 
\emph on
precedência
\emph default
 dos operadores.
 A precedência é importante para saber-se se determinada expressão necessidade
 de parênteses ou não para que a ordem desejada seja a que está efetivamente
 implementada.
 Por exemplo, o operador de soma possui precedência menor que o operador
 de multiplicação, o que pode indicar a necessidade de parênteses para preservar
 determinadas ordens de cálculo.
 A precedência, no C, pode ser observada na tabela 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:PrecedenciaDeOperadores"

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Precedência
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operações
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Símbolo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parênteses
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
( e )
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Função
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
f(p1, p2, ...)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Incremento ou Decremento
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
++ ou --
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unária
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- ou +
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiplicação, Divisão ou Módulo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*, / ou %
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soma ou Diferença
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ ou -
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:PrecedenciaDeOperadores"

\end_inset

Tabela de operadores na linguagem C.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Operadores especiais: casting e sizeof
\end_layout

\begin_layout Standard
Existem dois operadores especiais na linguagem C que podem ser usados junto
 a outras expressões: 
\emph on
sizeof 
\emph default
e 
\emph on
casting
\emph default
.
\end_layout

\begin_layout Standard
A função nativa da linguagem C 
\emph on
sizeof
\emph default
, retorna o tamanho (em bytes) da variável ou do tipo que esta em seu operando.
 Pode ser aplicado a 
\emph on
structs
\emph default
, 
\emph on
unions
\emph default
 e 
\emph on
enums.
 
\emph default
No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:SizeOf"

\end_inset

 demonstra-se a operação de 
\emph on
sizeof
\emph default
.
 Os valores que serão impressos são ambos 4, uma vez que os tipos 
\emph on
int 
\emph default
e 
\emph on
float 
\emph default
tem ambos 4 bytes.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/operador_sizeof.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:SizeOf"

\end_inset

Exemplo de utilização da função 
\emph on
sizeof
\emph default
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Type casting is a way to convert a variable from one data type to another
 data type.
 For example, if you want to store a long value into a simple integer then
 you can type cast long to int.
 You can convert values from one type to another explicitly using the cast
 operator as follows:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Já a operação de casting pode é uma maneira de converter um tipo de dado
 em outro tipo qualuqer.
 Por exemplo, quando queremos guardar um valor 
\emph on
long long 
\emph default
em um 
\emph on
int 
\emph default
podemes simplesmente fazer o casting de 
\emph on
long long 
\emph default
para 
\emph on
int 
\emph default
e a conversão é feita de maneira automática, por truncamento.
 Pode-se converter de um tipo para outro com a seguinte sintaxe:
\end_layout

\begin_layout Standard
\align center
(tipo) expressão
\end_layout

\begin_layout Standard
Um exemplo concreto de utilização do 
\emph on
casting 
\emph default
é visto no algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Casting"

\end_inset

.
 A saída no console desse programa será "media = 3.4", uma vez que ao fazer-se
 o casting para double da soma, ela torna-se double e a divisão do valor
 em ponto flutuante por um inteiro resultará em outro valor em ponto flutuante.
 A conversão para um tipo menor (ex: double
\begin_inset Formula $\rightarrow$
\end_inset

int) sempre terá que ser feita por casting, uma vez que a perda de precisão,
 em alguns casos pode significar um 
\emph on
bug
\emph default
!
\end_layout

\begin_layout Standard
Para calcular-se o tamanho de uma string qualquer, deve-se utilizar a função
 
\emph on
strlen
\emph default
 junto a 
\emph on
sizeof(char).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A01/operador_cast.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Casting"

\end_inset

Exemplo de operação de 
\emph on
casting
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Atribuição
\end_layout

\begin_layout Standard
As atribuições são mecanismos que alteram uma determinada variável alvo
 com o valor de uma expressão a qual possivelmente utiliza a própria variável
 como fonte.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operador
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Descrição
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atribuição
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiplica
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
/=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Divide
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Módulo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Soma
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Diferença
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<<=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shift para esquerda
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>>=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shift para direita
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
E binário
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
^=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OU EXCLUSIVO binário
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
|=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
OU binário
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
*Atribuição
\end_layout

\begin_layout Plain Layout
O operador de atribuição é o sinal de igual "=".
\end_layout

\begin_layout Plain Layout
Programa exemplo 3:
\end_layout

\begin_layout Plain Layout
#include <stdio.h>
\end_layout

\begin_layout Plain Layout
#include <conio.h>
\end_layout

\begin_layout Plain Layout
void main(void)
\end_layout

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
int idade,ano_atual,ano_nasceu;
\end_layout

\begin_layout Plain Layout
clrscr();
\end_layout

\begin_layout Plain Layout
printf("Ano ATUAL = "); 
\end_layout

\begin_layout Plain Layout
scanf("%d",&ano_atual);
\end_layout

\begin_layout Plain Layout
printf("Ano em que NASCEU = "); 
\end_layout

\begin_layout Plain Layout
scanf("%d",&ano_nasceu);
\end_layout

\begin_layout Plain Layout
idade = ano_atual - ano_nasceu; /* Atribuição */
\end_layout

\begin_layout Plain Layout
printf("Sua IDADE e
\backslash
' %d
\backslash
n",idade);
\end_layout

\begin_layout Plain Layout
getch();
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
O C permite usarmos o operador de atribuição em expressões que também envolvem
 outros operadores.
\end_layout

\begin_layout Plain Layout
if ((produto = x * y) < 0)
\end_layout

\begin_layout Plain Layout
- Primeiro "C" atribui o valor x * y ao produto, para depois avaliar a expressão.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Pré-processador C
\end_layout

\begin_layout Standard
O pré-processador C é um programa que examina o programa fonte escrito em
 C e executa certas modificações nele, baseado nas diretivas de compilação
 (ou diretivas do pré-processador).
 As diretivas de compilação são comandos que não são compilados, sendo dirigidos
 ao pré-processador, executado pelo compilador antes da execução do processo
 de compilação propriamente dito.
\end_layout

\begin_layout Standard
Portanto, o pré-processador modifica o programa fonte, que ainda não estaria
 pronto para ser entregue ao compilador.
 Todas as diretivas de compilação são iniciadas pelo caractere 
\emph on
#
\emph default
 (hashtag, sharp, jogo-da-velha).
 As diretivas podem ser colocadas em qualquer parte do programa, mas não
 podem ser colocadas na mesma linha que outra diretiva ou instrução.
 As principais diretivas de compilação são:
\end_layout

\begin_layout Itemize
#include
\end_layout

\begin_layout Itemize
#define
\end_layout

\begin_layout Itemize
#undef
\end_layout

\begin_layout Itemize
#ifdef
\end_layout

\begin_layout Itemize
#ifndef
\end_layout

\begin_layout Itemize
#if
\end_layout

\begin_layout Itemize
#else
\end_layout

\begin_layout Itemize
#elif
\end_layout

\begin_layout Itemize
#endif
\end_layout

\begin_layout Section
Diretivas em tempo de compilação
\end_layout

\begin_layout Standard
Algumas diretivas tem influência direta sobre o resultado da compilação.
 Nessa seção define-se algumas delas.
\end_layout

\begin_layout Subsection
#include
\end_layout

\begin_layout Standard
A diretiva #include diz ao pré-processador para incluir naquele ponto um
 arquivo especificado.
 Sua sintaxe é:
\end_layout

\begin_layout Standard
\align center
#include "nome_do_arquivo" 
\end_layout

\begin_layout Standard
\align center
#include <nome_do_arquivo>
\end_layout

\begin_layout Standard
A diferença entre se usar "" e <> é somente a ordem de procura nos diretórios
 pelo arquivo especificado.
 Se o arquivo tiver caminho completo, ou se o arquivo estiver em um diretório
 de trabalho relativo, usa-se a notação com aspas.
 Senão, se o arquivo estiver nos caminhos de procura pré-especificados do
 compilador, isto é, se ele for um arquivo do próprio sistema (como é o
 caso de arquivos como stdio.h, string.h, etc...), usa-se <arquivo>.
\end_layout

\begin_layout Subsection
#define
\end_layout

\begin_layout Standard
A diretiva #define pode ser usada em três escopos distintos.
 Um delae é para definir um símbolo o qual possa ser testado mais tarde.
 Um segundo, é para definir-se uma costante.
 E o terceiro e último escopo é para definir-se uma macro com parâmetros.
 Sendo assim, a sintaxe fica:
\end_layout

\begin_layout Itemize
Símbolo: #define nome_do_símbolo
\end_layout

\begin_layout Itemize
Constante: #define nome_da_constante valor_da_constante
\end_layout

\begin_layout Itemize
Macro: #define nome_da_macro(parâmetros) expressão_de_substituição
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A02/pi.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:MacroPI"

\end_inset

Exemplo de utilização de macro para utilização de constantes.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A02/min_max_macro.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:MacroMinMax"

\end_inset

Exemplo de definição de macro.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
#undef
\end_layout

\begin_layout Standard
Ela faz com que a macro de nome 
\emph on
nome_da_macro
\emph default
 seja apagada da tabela interna que guarda as macros.
 O compilador passa a partir deste ponto a não conhecer mais esta macro.
 A sintaxe é:
\end_layout

\begin_layout Standard
\align center
#undef nome_da_macro
\end_layout

\begin_layout Standard
O resultado dessa macro afeta diretamente o resultado das macros 
\emph on
#ifdef
\emph default
 e 
\emph on
#ifndef
\emph default
.
\end_layout

\begin_layout Subsection
#ifdef
\end_layout

\begin_layout Standard
O #ifdef é uma estrutura condicional e fazem parte das estruturas condicionais
 de pré-processamento o 
\emph on
#ifdef, #ifndef, #else, #elif 
\emph default
e o
\emph on
 #endif
\emph default
.
 Essas diretivas são processadas antes do início da compilação em si, então
 pode-se usá-las como condições para expressões que envolvam constantes
 e símbolos de pré-processamento.
 A sintaxe fica: 
\end_layout

\begin_layout Standard
\align center
#ifdef nome_do_símbolo
\end_layout

\begin_layout Standard
O código entre as duas diretivas só será compilado se o símbolo (ou constante)
 nome_do_símbolo já tiver sido definido.
 Há também a estrutura 
\emph on
#ifndef
\emph default
, que executa o código se o símbolo não tiver sido definido.
\end_layout

\begin_layout Standard
Lembre que o símbolo deve ter sido definido através da diretiva 
\emph on
#define
\emph default
.
\end_layout

\begin_layout Subsection
#ifndef
\end_layout

\begin_layout Standard
A diretiva #ifndef é utilizada para checar se a macro em questão está ou
 não definida.
 É usada da seguinte forma:
\end_layout

\begin_layout Standard
\align center
#ifndef nome_da_macro
\end_layout

\begin_layout Standard
Se a constatação for verdadeira, então o código dentro do trecho será executado,
 senão se houver trecho de 
\emph on
#else
\emph default
 ou 
\emph on
#elif,
\emph default
 referente a essa expressão, então esse trecho será executado.
\end_layout

\begin_layout Subsection
#else
\end_layout

\begin_layout Standard
A diretiva #else funciona como na estrutura de bloco if (condição) {...} else
 {...}:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

#ifdef WINDOWS
\end_layout

\begin_layout Plain Layout

/* será executado se a expressão for verdadeira */
\end_layout

\begin_layout Plain Layout

#define CABECALHO "windows_io.h"
\end_layout

\begin_layout Plain Layout

#else
\end_layout

\begin_layout Plain Layout

/* será executado se a expressão for falsa */
\end_layout

\begin_layout Plain Layout

#define CABECALHO "unix_io.h"
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\begin_layout Plain Layout

#include CABECALHO
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
#elif
\end_layout

\begin_layout Standard
A diretiva 
\emph on
#elif
\emph default
 é uma abreviação para 
\emph on
else if 
\emph default
e funciona como uma estrutura condicional desse tipo.
 A sintaxe é:
\end_layout

\begin_layout Standard
\align center
#elif expressão
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

#if expressão_1 
\end_layout

\begin_layout Plain Layout

//código...
\end_layout

\begin_layout Plain Layout

#elif expressão_2 
\end_layout

\begin_layout Plain Layout

//código...
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pode-se também utilizá-la com as demais diretivas como 
\emph on
#else
\emph default
.
 Só deve-se utilizar uma diretiva do tipo 
\emph on
#else
\emph default
 se ela deve for a última expressão da cadeia de expressões.
\end_layout

\begin_layout Section

\emph on
Header file
\emph default
: arquivo cabeçalho
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A02/header_exemplo.h

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:HeaderGuard"

\end_inset

Exemplo de utilização das macros condicionais para definir um 
\emph on
header guard
\emph default
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A header file is a file with extension .h which contains C function declarations
 and macro definitions and to be shared between several source files.
 There are two types of header files: the files that the programmer writes
 and the files that come with your compiler.
\end_layout

\begin_layout Plain Layout
You request the use of a header file in your program by including it, with
 the C preprocessing directive #include like you have seen inclusion of
 stdio.h header file, which comes along with your compiler.
\end_layout

\begin_layout Plain Layout
Including a header file is equal to copying the content of the header file
 but we do not do it because it will be very much error-prone and it is
 not a good idea to copy the content of header file in the source files,
 specially if we have multiple source file comprising our program.
\end_layout

\begin_layout Plain Layout
A simple practice in C or C++ programs is that we keep all the constants,
 macros, system wide global variables, and function prototypes in header
 files and include that header file wherever it is required.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um arquivo de header ou cabeçalho é um arquivo com extensão 
\emph on
.h 
\emph default
que contém declarações de funções C, de macros e de recursos a serem compartilha
dos por vários arquivos fontes 
\emph on
.c
\emph default
.
 Há dois tipos de arquivos de cabeçalho: os arquivos que são escritos pelo
 desenvolvedor e aqueles que vem junto ao compilador e fazem parte da biblioteca
 básica da linguagem.
\end_layout

\begin_layout Standard
O arquivo header é utilizado no programa ao pedir-se para o pré-processador
 incluir o arquivo desejado, com a diretiva de pré-processamento 
\emph on
#include
\emph default
.
 Um exemplo de inclusão comum é o arquivo 
\emph on
stdio.h
\emph default
, conforme visto nos algoritmos 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:MacroPI"

\end_inset

 e 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:MacroMinMax"

\end_inset

, para utilização de funções de entrada e saída como as funções, 
\emph on
scanf
\emph default
 e 
\emph on
printf
\emph default
.
\end_layout

\begin_layout Standard
Ao incluir-se um arquivo de cabeçalho, a ação esperada é como se o código
 fonte fosse copiado do arquivo original e colado no código fonte em questão.
 Não fazemos isso explicitamente porque essa atividade seria muito propícia
 a erros e não é uma boa ideia sair espalhando o conteúdo de cabeçalhos
 diversos por códigos fontes que os utilizam.
 
\end_layout

\begin_layout Standard
Uma boa prática é manter constantes, macros, funções e variáveis globais
 definidas em 
\emph on
headers 
\emph default
e incluí-lo sempre que for necessário utilizar essa variável.
 Para tal, faz-se necessário usar as estruturas 
\emph on
#ifndef
\emph default
, 
\emph on
#define
\emph default
 e 
\emph on
#endif
\emph default
, denominada 
\emph on
header guard
\emph default
, vista no algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:HeaderGuard"

\end_inset

.
 Nesse exemplo o MEU_HEADER_EXEMPLO_H_ é uma macro que serve como defensor
 (
\emph on
guard
\emph default
) desse header, para que se múltiplos arquivos o incluam, as variáveis,
 funções e estruturas que ali se encontram não seja definida múltiplas vezes
 no mesmo programa ou biblioteca, o que poderia mais tarde ocasionar erros
 de ligação do mesmo.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO - botar referência as páginas de ligação depois
\end_layout

\end_inset


\end_layout

\begin_layout Section
Concatenação de strings
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A02/macro_substitui_string.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:MacroSubstituiPorString"

\end_inset

Exemplo de utilização de substituição de parâmetro pela string que o representa,
 utilizando-se #.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O pré-processador C permite manipular uma cadeia de caracteres, isto é,
 strings.
 Isso se dá pela utilização dos operadores 
\emph on
#
\emph default
 e 
\emph on
##
\emph default
, os quais permitem substituir a grafia de um parâmetro e concatenar dois
 parâmetros, respectivamente.
 
\end_layout

\begin_layout Standard
A utilização do operador # na macro pode ser vista no código do algoritmo
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:MacroSubstituiPorString"

\end_inset

, o qual apresentará como saída no console "Estou aqui".
 Isso, porque o valor que é passado por parâmetro é convertido a string
 por meio da utilização do operador.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A02/macro_concat.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:MacroConcatParametros"

\end_inset

Demonstração de concatenação de símbolos pelo operador ##, na forma da macro
 CONCAT.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O operador ## por sua vez, faz a concatenação de dois parâmetros na forma
 de um único símbolo.
 No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:MacroConcatParametros"

\end_inset

, a variável 
\emph on
teste 
\emph default
é declarada com o valor 
\emph on
1000.
 
\emph default
No 
\emph on
printf
\emph default
 é utilizado a macro CONCAT com os parâmetros 
\emph on
tes 
\emph default
e 
\emph on
te
\emph default
.
 A concatenação dos dois símbolos em um só gera 
\emph on
teste
\emph default
, que coincide com o inteiro já definido anteriormente.
 Assim, o valor na saída de console impresso será "1000".
\end_layout

\begin_layout Chapter
Funções e estruturas da linguagem C
\end_layout

\begin_layout Standard
Nesse capítulo, fala-se sobre estruturas sintáticas e sua semântica de utilizaçã
o.
\end_layout

\begin_layout Section
If-then-else
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:If-then-else"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/par_ou_impar.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:ParOuImpar"

\end_inset

Exemplo de programa que checa se determinado número inteiro de entrada é
 par ou ímpar.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Gen/Image/Condition.eps
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LógicaDeCondicao"

\end_inset

Estrutura lógica de um if-then-else.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A estrutura condicional do C é o if-then-else, traduzindo se-então-senão
 pode ser vista logicamente na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LógicaDeLoop"

\end_inset

.
 Essa estrutura serve para alterar o fluxo dependendo de expressões condicionais
, ou seja, depende possivelmente de um valor obtido em tempo de execução.
 A linguagem de programação C assume que qualquer valor não zero é verdade,
 enquanto um valor zero (nulo) é assumido como falso.
 A sintaxe básica do if-then-else é:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

if (expressão_1) {
\end_layout

\begin_layout Plain Layout

	//Executa se expressão_1 for verdade
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else if(expressão_2) {
\end_layout

\begin_layout Plain Layout

	//Executa se expressão_2 for verdade e
\end_layout

\begin_layout Plain Layout

	//expressão_1 for mentira
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	//Executa se expressão_1 e a
\end_layout

\begin_layout Plain Layout

	//expressão_2 for mentira
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ParOuImpar"

\end_inset

, demonstra-se um exemplo de utilização dessas estruturas.
 Nesse caso, o algoritmo é utilizado para checar se determinado número é
 par, uma vez que o resto da divisão de um número par por 2 é sempre 0 por
 definição, então se "numero % 2 == 0" ele é par e cairá na saída de "eh
 par", senão cairá em "eh impar".
\end_layout

\begin_layout Subsection
If ternário
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The ? : Operator:
\end_layout

\begin_layout Plain Layout
We have covered conditional operator ? : in previous chapter which can be
 used to replace if...else statements.
 It has the following general form:
\end_layout

\begin_layout Plain Layout
Exp1 ? Exp2 : Exp3;
\end_layout

\begin_layout Plain Layout
Where Exp1, Exp2, and Exp3 are expressions.
 Notice the use and placement of the colon.
\end_layout

\begin_layout Plain Layout
The value of a ? expression is determined like this: Exp1 is evaluated.
 If it is true, then Exp2 is evaluated and becomes the value of the entire
 ? expression.
 If Exp1 is false, then Exp3 is evaluated and its value becomes the value
 of the expression.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Switch-case
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:SwitchCase"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

switch (variável)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	case constante_1 : //comandos;
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	case constante_2 : //comandos;
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	default : //comandos;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/switch_nota.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Indicativo"

\end_inset

Exemplo de utilização de 
\emph on
switch
\emph default
 para avaliação de uma nota indicativa.
\end_layout

\end_inset


\end_layout

\end_inset

No switch-case, tem-se uma variável cujo valor é testado com uma lista sucessiva
 e exasutiva de constantes inteiras ou caracteres.
 Ao encontrar uma coincidência, executa-se o comando ou blocos de comandos
 que estejam associados aquela constante.
 O comando obrigatório 
\emph on
default
\emph default
 é executado se não houver nenhuma coincidência.
 O comando 
\emph on
break
\emph default
 é usado para obrigar a saída do comando switch.
 
\end_layout

\begin_layout Standard
No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Indicativo"

\end_inset

, tem-se um indicativo de nota que pode assumir os valores qualitativos
 A, B, C, D ou F.
 Esses valores não estão associados diretamente a um conceito ou valor,
 mas eles indicam um determinado 
\emph on
rank
\emph default
 ou 
\emph on
score
\emph default
, sendo o melhor A e o pior F.
 Sendo assim, o programa referido imprime uma mensagem na saída de console
 de acordo com a nota obtida, caso-a-caso, usando uma estrutura de switch
 para tal.
 Nesse trecho, o valor da nota indicativa obtida foi 'B', portanto a saída
 obtida no console será "Muito bem!".
\end_layout

\begin_layout Section
Estruturas de repetição
\end_layout

\begin_layout Standard
Podem haver situações em que um bloco de código deve executar várias vezes.
 Uma estrutura de repetição, ou loop, possui comandos os quais são executados
 sequencialmentes.
 O primeiro comando em uma função é executado primeiro, seguido pelo segundo
 e assim por diante.
\end_layout

\begin_layout Standard
Linguagens de programação providenciam várias estruturas de controle que
 permitem alterar o fluxo de execução.
 Um comando desse tipo já visto é o if-then-else, na seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:If-then-else"

\end_inset

.
 Existem outros comandos que alteram diretamente o fluxo de execução e eles
 serão vistos nessa seção também.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Gen/Image/Loops.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LógicaDeLoop"

\end_inset

Estrutura lógica de um loop 
\emph on
while
\emph default
 expresso na forma de um grafo orientado.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um loop vai possuir uma estrutura de execução conforme visto na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LógicaDeLoop"

\end_inset

.
 A partir dessa lógica básica, existirão três tipos de estruturas de repetição:
 for, while, do-while.
\end_layout

\begin_layout Subsection
While
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/while.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:While"

\end_inset

Exemplo de utilização 
\emph on
while.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Um loop que executa comandos enquanto a condição básica for verdade.
 A sintaxe é:
\end_layout

\begin_layout Standard
\align center
while (condição) { comandos; }
\end_layout

\begin_layout Standard
Os 
\emph on
comandos 
\emph default
podem ser um ou mais comandos e inclusive blocos de comandos.
 A condição é qualquer expressão que retorne um valor inteiro, seja ele
 zero (falso) ou não zero (verdade).
 Nota-se que um loop 
\emph on
while 
\emph default
pode jamais rodar, uma vez que se a condição não for verdade na primeira
 execução, o loop sequer executará seu bloco de código, conforme visto na
 figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LógicaDeLoop"

\end_inset

.
 No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:While"

\end_inset

, a saída esperada será:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a: 10
\end_layout

\begin_layout Plain Layout

a: 11
\end_layout

\begin_layout Plain Layout

a: 12
\end_layout

\begin_layout Plain Layout

a: 13
\end_layout

\begin_layout Plain Layout

a: 14
\end_layout

\begin_layout Plain Layout

a: 15
\end_layout

\begin_layout Plain Layout

a: 16
\end_layout

\begin_layout Plain Layout

a: 17
\end_layout

\begin_layout Plain Layout

a: 18
\end_layout

\begin_layout Plain Layout

a: 19
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Do-while
\end_layout

\begin_layout Standard
Ao contrário o while que testa o loop antes de executar a iteração, o 
\emph on
do-while
\emph default
 executa o corpo do loop antes mesmo de fazer qualquer checagem condicional.
 A checagem será feita somente após o último comando de cada loop.
 Este efeito pode ser observado na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LógicaDoWhile"

\end_inset

, a qual demonstra a lógica de execução do 
\emph on
do-while
\emph default
.
 A sintaxe é:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

do 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	códigos;
\end_layout

\begin_layout Plain Layout

} while (condição);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Gen/Image/DoWhile.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LógicaDoWhile"

\end_inset

Estrutura lógica de um loop 
\emph on
do-while
\emph default
 expresso na forma de um grafo orientado.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/do_while.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:DoWhile"

\end_inset

Exemplo de utilização 
\emph on
do-while.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nota-se que a condição aparece no final do loop então se a condição for
 verdadeira, o fluxo retorna ao começo do corpo e continua a execução até
 que a condição seja falsa.
 No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:DoWhile"

\end_inset

, vê-se um exemplo de utilização do do-while.
 Nesse caso, o resultado é idêntico aquele obtido com o while, isto é:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a: 10
\end_layout

\begin_layout Plain Layout

a: 11
\end_layout

\begin_layout Plain Layout

a: 12
\end_layout

\begin_layout Plain Layout

a: 13
\end_layout

\begin_layout Plain Layout

a: 14
\end_layout

\begin_layout Plain Layout

a: 15
\end_layout

\begin_layout Plain Layout

a: 16
\end_layout

\begin_layout Plain Layout

a: 17
\end_layout

\begin_layout Plain Layout

a: 18
\end_layout

\begin_layout Plain Layout

a: 19
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
For
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:For"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../Gen/Image/For.eps
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LógicaDoFor"

\end_inset

Estrutura lógica de um loop 
\emph on
for
\emph default
 expresso na forma de um grafo orientado.
 A estrutura é mais complexa em função do 
\emph on
início
\emph default
 e 
\emph on
incremento.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/for.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:For"

\end_inset

Exemplo de utilização 
\emph on
for
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O loop for é uma estrutura de repetição a qual permite que o loop seja escrito
 de maneira a executar um número específico de vezes pela sua sintaxe.
 É ela:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

for (iníncio; condição; incremento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	código;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
O fluxo de controle do loop, visto na figura 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LógicaDoFor"

\end_inset

, funciona da seguinte forma: primeiramente, o passo inicial é executado,
 somente uma vez.
 Esse passo permite a declaração e controle das variáveis de loop, que inclusive
 podem ser usadas nas outras expressões do loop, como a 
\emph on
condição 
\emph default
e o 
\emph on
incremento
\emph default
.
 Essa expressão é opcional e pode ser omitida, mantendo-se apenas o ';'.
 Depois, a condição é validade e se verdade, executa-se o corpo do for,
 com todas as declarações em sequência.
 Se falso, o controle vai direto para o primeiro comando após o loop.
\end_layout

\begin_layout Standard
Ao término da execução do corpo da iteração, o condicional é checado novamente
 e, se verdade, ocorre o 
\emph on
incremento
\emph default
.
 Esse último, permite que quaisquer variáveis do loop sejam controladas
 e pode, assim como o 
\emph on
início
\emph default
, ser omitido.
 Nesse caso, não é necessário deixar um ';', mas cada declaração desse bloco
 devem ser separadas por ';', como de costume.
 Quando a condição torna-se falsa, o loop termina e pula-se para próxima
 instrução após o loop.
\end_layout

\begin_layout Standard
No algorimo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:For"

\end_inset

, tem-se o mesmo resultado obtido para os 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:DoWhile"

\end_inset

 e 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:While"

\end_inset

.
 A impressão da variável a de 10 a 19:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a: 10
\end_layout

\begin_layout Plain Layout

a: 11
\end_layout

\begin_layout Plain Layout

a: 12
\end_layout

\begin_layout Plain Layout

a: 13
\end_layout

\begin_layout Plain Layout

a: 14
\end_layout

\begin_layout Plain Layout

a: 15
\end_layout

\begin_layout Plain Layout

a: 16
\end_layout

\begin_layout Plain Layout

a: 17
\end_layout

\begin_layout Plain Layout

a: 18
\end_layout

\begin_layout Plain Layout

a: 19
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
break
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Break"

\end_inset


\end_layout

\begin_layout Standard
A instrução e palavra-chave 
\emph on
break 
\emph default
podeser usado em dois contextos bem definidos:
\end_layout

\begin_layout Enumerate
Dentro de um loop, causando o término imediato do mesmo e indo para a próxima
 instrução depois do fim do loop.
\end_layout

\begin_layout Enumerate
Terminar um 
\emph on
case
\emph default
, específico, no switch-case, visto na seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SwitchCase"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/break.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Break"

\end_inset

Exemplo de utilização 
\emph on
break
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se o loop relativo ao break for um loop 
\emph on
aninhado
\emph default
 (interno a outro), então somente a execução do mais interno será parada
 e começará a execucão da próxima linha de código do loop externo logo após
 do bloco de código referente ao loop aninhado.
 Um exemplo de utilização do break pode ser visto no código 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Break"

\end_inset

, o resultado final da execução do loop é afetado, uma vez que o controle
 não é mais o mesmo, fazendo com que o resultado da saída seja:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a: 10
\end_layout

\begin_layout Plain Layout

a: 11
\end_layout

\begin_layout Plain Layout

a: 12
\end_layout

\begin_layout Plain Layout

a: 13
\end_layout

\begin_layout Plain Layout

a: 14
\end_layout

\begin_layout Plain Layout

a: 15
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
continue
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/continue.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Continue"

\end_inset

Exemplo de utilização 
\emph on
continue
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O 
\emph on
continue
\emph default
 é uma instrução que funciona de maneira similar ao 
\emph on
break
\emph default
, da seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Break"

\end_inset

.
 Porém, ao invés de forçar o término do loop ele força que o loop vá para
 a próxima iteração, pulando todo o código referente aos demais blocos de
 execução até então.
 Para o loop 
\emph on
for
\emph default
, seção 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:For"

\end_inset

, o continue faz com que o teste condicional e de incremento sejam executados,
 enquanto para os 
\emph on
while 
\emph default
e 
\emph on
do-while
\emph default
, ele passa o controle do programa para os testes condicionais.
 
\end_layout

\begin_layout Standard
No código do algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Continue"

\end_inset

, temos a instrução condicional checando se o valor de a é igual a 15, nesse
 caso, pula-se a iteração, adicionando um ao valor de a e usando o continue,
 pulando os comandos abaixo (incluindo o printf).
 Por isso, o resultado final, na saída de console, fica:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a: 10
\end_layout

\begin_layout Plain Layout

a: 11
\end_layout

\begin_layout Plain Layout

a: 12
\end_layout

\begin_layout Plain Layout

a: 13
\end_layout

\begin_layout Plain Layout

a: 14
\end_layout

\begin_layout Plain Layout

a: 16
\end_layout

\begin_layout Plain Layout

a: 17
\end_layout

\begin_layout Plain Layout

a: 18
\end_layout

\begin_layout Plain Layout

a: 19
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The continue statement in C programming language works somewhat like the
 break statement.
 Instead of forcing termination, however, continue forces the next iteration
 of the loop to take place, skipping any code in between.
\end_layout

\begin_layout Plain Layout
For the for loop, continue statement causes the conditional test and increment
 portions of the loop to execute.
 For the while and do...while loops, continue statement causes the program
 control passes to the conditional tests.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
goto
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/goto.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:GoTo"

\end_inset

Exemplo de utilização 
\emph on
goto
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pode-se existir uma situação em que faz-se necessário a utilização de uma
 quebra de fluxo incondicional, o chamado 
\emph on
pulo.
 
\emph default
Nesse caso, pode-se utilizar o 
\emph on
goto
\emph default
.
 Porém, por motivos de entendimento e de manutenção da legibilidade de código,
 essa instrução deve-se ser utilizada com muita cautela.
 Uma grande sequência de pulos pode tornar o programa simplesmente muito
 difícil de compreender e dar manutenção! Além disso, qualquer programa
 que use um goto pode ser escrito por outras instruções equivalentes e portanto
 não usá-lo.
\end_layout

\begin_layout Standard
No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:GoTo"

\end_inset

, utiliza-se a label LOOP para referenciar o começo do loop.
 Checa-se o caso da variável a ser 15 e pula-se a iteração pela utilização
 do goto para a label.
 Isso é, tem-se o mesmo resultado que o obtido pela utilização do 
\emph on
continue
\emph default
, do algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Continue"

\end_inset

.
 O resultado fica portanto:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a: 10
\end_layout

\begin_layout Plain Layout

a: 11
\end_layout

\begin_layout Plain Layout

a: 12
\end_layout

\begin_layout Plain Layout

a: 13
\end_layout

\begin_layout Plain Layout

a: 14
\end_layout

\begin_layout Plain Layout

a: 16
\end_layout

\begin_layout Plain Layout

a: 17
\end_layout

\begin_layout Plain Layout

a: 18
\end_layout

\begin_layout Plain Layout

a: 19
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A goto statement in C programming language provides an unconditional jump
 from the goto to a labeled statement in the same function.
\end_layout

\begin_layout Plain Layout
NOTE: Use of goto statement is highly discouraged in any programming language
 because it makes difficult to trace the control flow of a program, making
 the program hard to understand and hard to modify.
 Any program that uses a goto can be rewritten so that it doesn't need the
 goto.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Arrays
\end_layout

\begin_layout Standard
No C, tem-se uma estrutura de dados básica da linguagem, chamada de 
\emph on
array
\emph default
 ou 
\emph on
arranjos
\emph default
.
 Nela pode-se guardar uma coleção de tamanho fixo, sequencial, de elementos
 do mesmo tipo.
 O array é usado para guardar uma coleção de dados, mas costuma ser mais
 fácil pensar em array como uma maneira de guardar um conjunto de variáveis
 do mesmo tipo.
 Isto é, ao invés de utlizar-se variáveis como 
\emph on
numero0, numero1, ...., numeroN
\emph default
, declara-se somente uma variável e utiliza-se 
\emph on
numeros 
\emph default
por meio de um índice sequencial de acesso para representar individualmente
 as variáveis.
 Fica assim: 
\emph on
numero[0], numero[1], ..., numero[N]
\emph default
.
\end_layout

\begin_layout Standard
Todos os arrays consistem em elementos contíguos (contínuos e íntegros)
 em endereços de memória.
 O menor endereço corresponde ao primeiro elemento enquanto o endereço de
 memória mais alto corresponde ao último endereço:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Índice
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Acesso
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
numero[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
numero[1]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
numero[2]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
...
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
numero[N]
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Declaração
\end_layout

\begin_layout Standard
Para declarar-se um array basta usar a sintaxe:
\end_layout

\begin_layout Standard
\align center
tipo nomeDoArray[tamanhoDoArray];
\end_layout

\begin_layout Standard
Isso funciona para o chamado array unidimensional.
 O 
\emph on
tamanhoDoArray
\emph default
 deve ser um inteiro positivo constante maior que 0.
 O 
\emph on
tipo 
\emph default
pode ser qualquer um válido no C.
 Como exemplo concreto, imagine que seja declarado um array de tamanho 10
 de double, chamado balancete.
 Em código:
\end_layout

\begin_layout Standard
\align center
double balancete[10];
\end_layout

\begin_layout Standard
A partir dessa instrução, 
\emph on
balancete 
\emph default
será uma variável acessível no escopo e que pode armazenar até 10 variáveis
 doubles.
\end_layout

\begin_layout Subsection
Inicialização
\end_layout

\begin_layout Standard
O array pode ser inicializado numa só instrução:
\end_layout

\begin_layout Standard
\align center
double balancete[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
\end_layout

\begin_layout Standard
Na inicialização o número de valores entre as chaves não podem ser maior
 do que o número de elementos declarados como tamanho, entre os colchetes.
 Se o tamanho do array for omitido, um de tamanho grande o suficiente para
 armazenar as variáveis declaradas será criado.
 Assim, escreve-se:
\end_layout

\begin_layout Standard
\align center
double balancete[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
\end_layout

\begin_layout Standard
Nesse caso, os dois arrays serão idênticos.
 Uma outra possibilidade, é definir-se somente um elemento do array:
\end_layout

\begin_layout Standard
\align center
balancete[4] = 52.0;
\end_layout

\begin_layout Standard
A atribuição acima fará com que o quinto elemento do array 
\emph on
balancete 
\emph default
receba o valor 50.0.
 Todos os arrays tem 0 como seu primeiro índice e seu tamanho total decrescido
 de 1 como o último.
 Seguindo a representação anterior, após o comando te atribuição ao índice
 4, o array fica:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Índice
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Valor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
52.0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Acesso
\end_layout

\begin_layout Standard
Um elemento é acessado por meio do seu índice referente e o nome da variável
 array.
 Isso é feito utilizando-se o nome do array e o índice entre colchetes logo
 após.
 Por exemplo:
\end_layout

\begin_layout Standard
\align center
double valor = balancete[9];
\end_layout

\begin_layout Standard
Essa instrução irá obter o décimo elemento do array 
\emph on
balancete 
\emph default
e atribuir a variável double declarada na instrução, denominada 
\emph on
valor
\emph default
.
 Um exemplo mais complexo pode ser observado no algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Array"

\end_inset

.
 Nesse caso, o array é acessado em todas as suas posições, sendo que cada
 uma delas receberá a soma de seu índice mais 128.
 No final, todos os valores do array são impressos, um por linha, com 
\emph on
printf
\emph default
.
 O resultado no console é:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/array.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Array"

\end_inset

Exemplo de iteração sobre um 
\emph on
array
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

n[0] = 128
\end_layout

\begin_layout Plain Layout

n[1] = 129
\end_layout

\begin_layout Plain Layout

n[2] = 130
\end_layout

\begin_layout Plain Layout

n[3] = 131
\end_layout

\begin_layout Plain Layout

n[4] = 132
\end_layout

\begin_layout Plain Layout

n[5] = 133
\end_layout

\begin_layout Plain Layout

n[6] = 134
\end_layout

\begin_layout Plain Layout

n[7] = 135
\end_layout

\begin_layout Plain Layout

n[8] = 136
\end_layout

\begin_layout Plain Layout

n[9] = 137
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arrays n-dimensionais
\end_layout

\begin_layout Standard
C aceita arrays de múltiplas dimensões.
 Em sua forma geral, declara-se eles da seguinte forma:
\end_layout

\begin_layout Standard
\align center
tipo nomeDoArray[tamanho1][tamanho2]...[tamanhoN];
\end_layout

\begin_layout Standard
Por exemplo, a declaração de um array quadridimensional seria algo como:
\end_layout

\begin_layout Standard
\align center
int quadri[10][2][5][18];
\end_layout

\begin_layout Standard
Para acessá-los, deve-se usar o número de índices entre colchetes referentes
 a sua dimensionalidade.
\end_layout

\begin_layout Section
Arrays bi-dimensionais
\end_layout

\begin_layout Standard
A forma mais simple de array multi-dimensional é a bi-dimensional.
 Um array bi-dimensional é, em sua essência, uma lista de arrays uni-dimensionai
s.
 Para declarar-se um array desse tipo, deve-se usar duas constantes distintas
 de tamanho, as quais podem inclusive assumir valores idênticos:
\end_layout

\begin_layout Standard
\align center
tipo nomeDoArray[x][y];
\end_layout

\begin_layout Subsection
Inicialização
\end_layout

\begin_layout Standard
Qualquer tipo válido para um array de uma dimensão será valido para o bi-dimensi
onal.
 Pode-se pensar nele como uma tabela com 
\emph on
x
\emph default
 linhas e 
\emph on
y
\emph default
 colunas.
 Assim, essa é uma estrutura natural para tudo que possa ser representado
 por tabelas e matrizes.
 Um array com 3 linhas e 4 colunas seria algo como:
\end_layout

\begin_layout Standard
\align center
int a[3][4];
\end_layout

\begin_layout Standard
A inicialização desse array, como no caso de somente uma dimensão, será
 também por meio de valores entre chaves.
 Assim, pode-se inicializar 
\emph on
a
\emph default
 como um array de arrays, ou seja:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

int a[3][4] = { 
\end_layout

\begin_layout Plain Layout

	{0, 1, 2, 3} , /* linha 0 */
\end_layout

\begin_layout Plain Layout

	{4, 5, 6, 7} , /* linha 1 */
\end_layout

\begin_layout Plain Layout

	{8, 9, 10, 11} /* linha 2 */
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As chaves internas são extras, ou seja, opcionais.
 Elas estão ali somente para facilitar o entendimento do que está acontecendo.
 Essa mesma inicialização poderia dar-se da seguinte forma, obtendo-se o
 mesmo resultado:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Acesso
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset External
	template CSourceNoLnNoFrame
	filename ../Code/A03/bi_array.c

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:BiArray"

\end_inset

Exemplo de iteração sobre um 
\emph on
array
\emph default
 
\emph on
bidimensional
\emph default
.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Uma variável de um array 2-dimensional pode ser acessada pela utilização
 de índices subescritos, i.
 e., índice de linha e de coluna em sequência.
 Por exemplo:
\end_layout

\begin_layout Standard
\align center
int valor = a[10][24];
\end_layout

\begin_layout Standard
Assim, o elemento da linha 10, coluna 24 do array seria atribuído a variável
 valor.
 No algoritmo 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:BiArray"

\end_inset

, tem-se a inicialização e iteração de um array.
 A saída do programa é:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\small},tabsize=4,extendedchars=true"
inline false
status open

\begin_layout Plain Layout

a[0][0] = 0
\end_layout

\begin_layout Plain Layout

a[0][1] = 0
\end_layout

\begin_layout Plain Layout

a[1][0] = 1
\end_layout

\begin_layout Plain Layout

a[1][1] = 2
\end_layout

\begin_layout Plain Layout

a[2][0] = 2
\end_layout

\begin_layout Plain Layout

a[2][1] = 4
\end_layout

\begin_layout Plain Layout

a[3][0] = 3
\end_layout

\begin_layout Plain Layout

a[3][1] = 6
\end_layout

\begin_layout Plain Layout

a[4][0] = 4
\end_layout

\begin_layout Plain Layout

a[4][1] = 8
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
C programming language allows multidimensional arrays.
 Here is the general form of a multidimensional array declaration:
\end_layout

\begin_layout Plain Layout
type name[size1][size2]...[sizeN];
\end_layout

\begin_layout Plain Layout
For example, the following declaration creates a three dimensional 5 .
 10 .
 4 integer array:
\end_layout

\begin_layout Plain Layout
int threedim[5][10][4];
\end_layout

\begin_layout Plain Layout
Two-Dimensional Arrays:
\end_layout

\begin_layout Plain Layout
The simplest form of the multidimensional array is the two-dimensional array.
 A two-dimensional array is, in essence, a list of one-dimensional arrays.
 To declare a two-dimensional integer array of size x,y you would write
 something as follows:
\end_layout

\begin_layout Plain Layout
type arrayName [ x ][ y ];
\end_layout

\begin_layout Plain Layout
Where type can be any valid C data type and arrayName will be a valid C
 identifier.
 A two-dimensional array can be think as a table which will have x number
 of rows and y number of columns.
 A 2-dimensional array a, which contains three rows and four columns can
 be shown as below:
\end_layout

\begin_layout Plain Layout
Two Dimensional Arrays in C
\end_layout

\begin_layout Plain Layout
Thus, every element in array a is identified by an element name of the form
 a[ i ][ j ], where a is the name of the array, and i and j are the subscripts
 that uniquely identify each element in a.
\end_layout

\begin_layout Plain Layout
Initializing Two-Dimensional Arrays:
\end_layout

\begin_layout Plain Layout
Multidimensional arrays may be initialized by specifying bracketed values
 for each row.
 Following is an array with 3 rows and each row has 4 columns.
\end_layout

\begin_layout Plain Layout
int a[3][4] = { 
\end_layout

\begin_layout Plain Layout
{0, 1, 2, 3} , /* initializers for row indexed by 0 */
\end_layout

\begin_layout Plain Layout
{4, 5, 6, 7} , /* initializers for row indexed by 1 */
\end_layout

\begin_layout Plain Layout
{8, 9, 10, 11} /* initializers for row indexed by 2 */
\end_layout

\begin_layout Plain Layout
};
\end_layout

\begin_layout Plain Layout
The nested braces, which indicate the intended row, are optional.
 The following initialization is equivalent to previous example:
\end_layout

\begin_layout Plain Layout
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
\end_layout

\begin_layout Plain Layout
Accessing Two-Dimensional Array Elements:
\end_layout

\begin_layout Plain Layout
An element in 2-dimensional array is accessed by using the subscripts, i.e.,
 row index and column index of the array.
 For example:
\end_layout

\begin_layout Plain Layout
int val = a[2][3];
\end_layout

\begin_layout Plain Layout
The above statement will take 4th element from the 3rd row of the array.
 You can verify it in the above diagram.
 Let us check below program where we have used nested loop to handle a two
 dimensional array:
\end_layout

\begin_layout Plain Layout
#include <stdio.h>
\end_layout

\begin_layout Plain Layout
int main ()
\end_layout

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
/* an array with 5 rows and 2 columns*/
\end_layout

\begin_layout Plain Layout
int a[5][2] = { {0,0}, {1,2}, {2,4}, {3,6},{4,8}};
\end_layout

\begin_layout Plain Layout
int i, j;
\end_layout

\begin_layout Plain Layout
/* output each array element's value */
\end_layout

\begin_layout Plain Layout
for ( i = 0; i < 5; i++ )
\end_layout

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
for ( j = 0; j < 2; j++ )
\end_layout

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
printf("a[%d][%d] = %d
\backslash
n", i,j, a[i][j] );
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
return 0;
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
When the above code is compiled and executed, it produces the following
 result:
\end_layout

\begin_layout Plain Layout
a[0][0]: 0
\end_layout

\begin_layout Plain Layout
a[0][1]: 0
\end_layout

\begin_layout Plain Layout
a[1][0]: 1
\end_layout

\begin_layout Plain Layout
a[1][1]: 2
\end_layout

\begin_layout Plain Layout
a[2][0]: 2
\end_layout

\begin_layout Plain Layout
a[2][1]: 4
\end_layout

\begin_layout Plain Layout
a[3][0]: 3
\end_layout

\begin_layout Plain Layout
a[3][1]: 6
\end_layout

\begin_layout Plain Layout
a[4][0]: 4
\end_layout

\begin_layout Plain Layout
a[4][1]: 8
\end_layout

\begin_layout Plain Layout
As explained above, you can have arrays with any number of dimensions, although
 it is likely that most of the arrays you create will be of one or two dimension
s.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Funções
\end_layout

\begin_layout Chapter
Structs & ponteiros
\end_layout

\begin_layout Chapter
Entrada e saída
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
6.1 - abs (Valor Absoluto Inteiro)
\end_layout

\begin_layout Plain Layout
Sintaxe: int abs (int x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
stdlib.h
\end_layout

\begin_layout Plain Layout
6.2 - fabs (Valor Absoluto Real)
\end_layout

\begin_layout Plain Layout
Sintaxe: float fabs (float x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
stdlib.h
\end_layout

\begin_layout Plain Layout
6.3 - asin (Arco Seno)
\end_layout

\begin_layout Plain Layout
Sintaxe: double asin (double x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
Faixa: -pi/2 pi/2 /* resposta em radianos */
\end_layout

\begin_layout Plain Layout
6.4 - acos (Arco Cosseno)
\end_layout

\begin_layout Plain Layout
Sintaxe: double acos (double x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
Faixa: 0 pi /* resposta em radianos */
\end_layout

\begin_layout Plain Layout
6.5 - atan (Arco Tangente)
\end_layout

\begin_layout Plain Layout
Sintaxe: double atan (double x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
Faixa: -pi/2 pi/2
\end_layout

\begin_layout Plain Layout
6.6 - cos (Cosseno)
\end_layout

\begin_layout Plain Layout
Sintaxe: double cos (double x); x em radianos
\end_layout

\begin_layout Plain Layout
Prototype: math.h 
\end_layout

\begin_layout Plain Layout
Faixa: -1 1 
\end_layout

\begin_layout Plain Layout
6.7 - sin (Seno)
\end_layout

\begin_layout Plain Layout
Sintaxe: double sin (double x); x em radianos
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
Faixa: -1 1
\end_layout

\begin_layout Plain Layout
6.8 - exp (Expoente - e ) 
\end_layout

\begin_layout Plain Layout
Sintaxe: double exp (double x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
6.9 - pow (Potência)
\end_layout

\begin_layout Plain Layout
Sintaxe: double pow (double x, double y);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
6.10 - sqrt (Raiz Quadrada)
\end_layout

\begin_layout Plain Layout
Sintaxe: double sqrt (double x);'
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
6.11 - log (Logarítmo Natural)
\end_layout

\begin_layout Plain Layout
Sintaxe: double log (double x);
\end_layout

\begin_layout Plain Layout
Prototype math.h
\end_layout

\begin_layout Plain Layout
6.12 - atof (Converte String em Ponto Flutuante)
\end_layout

\begin_layout Plain Layout
Sintaxe: double atof (const char *s);
\end_layout

\begin_layout Plain Layout
Prototype: math.h e stdlib.h
\end_layout

\begin_layout Plain Layout
6.13 - atoi (Converte String em Inteiro)
\end_layout

\begin_layout Plain Layout
Sintaxe: int atoi (const char *s);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
6.14 - atol (Converte String em Inteiro Longo)
\end_layout

\begin_layout Plain Layout
Sintaxe: long int atol (const char *s);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
6.15 - log10 (Logarítmo na Base 10)
\end_layout

\begin_layout Plain Layout
Sintaxe: double log10 (double x);
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
6.16 - tan (Tangente)
\end_layout

\begin_layout Plain Layout
Sintaxe: double tan (double x); x em radianos
\end_layout

\begin_layout Plain Layout
Prototype: math.h
\end_layout

\begin_layout Plain Layout
6.17 - max (Valor Máximo)
\end_layout

\begin_layout Plain Layout
Sintaxe: int max (int a, int b);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
6.18 - min (Valor Mínimo)
\end_layout

\begin_layout Plain Layout
Sintaxe: int min (int a, int b);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
6.19 - rand (Numero Aleatório)
\end_layout

\begin_layout Plain Layout
Sintaxe: int rand (void);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
Faixa: 0 32767
\end_layout

\begin_layout Plain Layout
6.20 - random (Número Aleatório)
\end_layout

\begin_layout Plain Layout
Sintaxe: int random (int limite);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
Faixa: 0 (limite - 1)
\end_layout

\begin_layout Plain Layout
6.21 - randomize (Inicializa a Geração de Números Aleatórios)
\end_layout

\begin_layout Plain Layout
Sintaxe: void randomize (void);
\end_layout

\begin_layout Plain Layout
Prototype: stdlib.h
\end_layout

\begin_layout Plain Layout
6.22 - system (Executa Comandos e Arquivos .COM e .EXE do Sistema Operacional)
 
\end_layout

\begin_layout Plain Layout
Sintaxe: int system (const char *comando);
\end_layout

\begin_layout Plain Layout
Prototype: process.h e stdlib.h
\end_layout

\begin_layout Plain Layout
Retorna: 0 ok e -1 erro
\end_layout

\begin_layout Plain Layout
Exemplos: system ("dir"); 
\end_layout

\begin_layout Plain Layout
system ("sk");
\end_layout

\begin_layout Plain Layout
system ("dir *.c");
\end_layout

\end_inset


\end_layout

\end_body
\end_document
